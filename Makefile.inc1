#
# $FreeBSD: src/Makefile.inc1,v 1.141.2.62 2003/04/06 19:54:00 dwmalone Exp $
#
# This file defines the user-driven targets.
#
# Standard targets are documented in the makefiles in /usr/share/mk and include:
#	obj depend all install clean cleandepend cleanobj
#
# Build-time options are documented in make.conf(5).
#

DFLYVERSION!=   awk '/^\#define[[:blank:]]__DragonFly_version/ {print $$3}' \
		< ${.CURDIR}/sys/sys/param.h

OSREL!=		echo ${DFLYVERSION} | \
		awk '{a=int($$1/100000); b=int(($$1-(a*100000))/100); \
		print a "." b}'

# Put initial settings here.
SUBDIR=

# /libexec/ld-elf.so.2 needs to be installed first
# Otherwise, install(1) beeing a dynamically linked binary will fail
# during the first upgrade from a static to a dynamic world
SUBDIR+= libexec

# We need to do include and lib early.
#
SUBDIR+= include
SUBDIR+= lib

SUBDIR+= bin
.if !defined(NO_GAMES)
SUBDIR+= games
.endif
SUBDIR+= gnu
SUBDIR+= sbin
.if !defined(NO_SHARE)
SUBDIR+= share
.endif
SUBDIR+= stand
SUBDIR+= sys
SUBDIR+= usr.bin
SUBDIR+= usr.sbin

SUBDIR+= etc

# These are last, since it is nice to at least get the base system
# rebuilt before you do them.
.if defined(LOCAL_DIRS)
.for _DIR in ${LOCAL_DIRS}
.if exists(${.CURDIR}/${_DIR}) & exists(${.CURDIR}/${_DIR}/Makefile)
SUBDIR+= ${_DIR}
.endif
.endfor
.endif

.if defined(SUBDIR_OVERRIDE)
SUBDIR=		${SUBDIR_OVERRIDE}
.endif

.if defined(NOCLEANDIR)
CLEANDIR=	clean cleandepend
.else
CLEANDIR=	cleandir
.endif

.if defined(NO_CLEAN)
NOCLEAN=	# defined
.endif

# Base of the checked-out dports repo to use when WITH_DPORTS is enabled.
# This will be null-mounted and merged with /usr/src/dports.base in the
# chroot (buildportschroot) via build-all and install-all.
#
DPORTSBASE?=	/usr/dports

# Object directory base in primary make.  Note that when we rerun make
# from inside this file we change MAKEOBJDIRPREFIX to the appropriate
# subdirectory because the rest of the build system needs it that way.
# The original object directory base is saved in OBJTREE.
#
MAKEOBJDIRPREFIX?=	/usr/obj
OBJTREE?=		${MAKEOBJDIRPREFIX}

# Used for stage installs and pathing
#
DESTDIRBASE:=		${OBJTREE}${.CURDIR}

# Remove DESTDIR from MAKEFLAGS.  It is present in the environment
# anyhow, and we need to be able to override it for stage installs
.MAKEFLAGS:=	${.MAKEFLAGS:NDESTDIR=*}

# This section sets the tools used to build the world/kernel
WORLD_CCVER?=		gcc80
WORLD_LDVER?=		ld.bfd
WORLD_BINUTILSVER?=	binutils234

.if !defined(NO_BACKUP)
# Set the backup parameters if they are not already defined
#
WORLD_BACKUP?=		/var/backups/world_backup
AUTO_BACKUP?=		${OBJTREE}/world_backup/${DESTDIR}
.endif

TARGET_ARCH?=	${MACHINE_ARCH}
.if ${TARGET_ARCH} == ${MACHINE_ARCH}
TARGET?=	${MACHINE}
.else
TARGET?=	${TARGET_ARCH}
.endif
.if make(buildworld)
BUILD_ARCH!=	sysctl -n hw.machine_arch

# temporary until everybody has converted to x86_64
.if ${BUILD_ARCH} == "amd64"
BUILD_ARCH=	x86_64
.endif

.if ${MACHINE_ARCH} != ${BUILD_ARCH}
.error To cross-build, set TARGET_ARCH.
.endif
.endif

# XXX this is ugly and we need to come up with a nicer solution
.if !defined(TARGET_PLATFORM)
.if ${TARGET_ARCH} == "x86_64"
TARGET_PLATFORM= pc64
.else
.error Unknown target architecture.
.endif
.endif

THREAD_LIB?=	thread_xu

# BTOOLS	(Natively built) All non-cross-development tools that the
#		main build needs.  This includes things like 'mkdir' and 'rm'.
#		We will not use the native system's exec path once we start
#		on WORLD.  (bootstrap-tools and build-tools or BTOOLS)
#
# CTOOLS	(Natively built) Cross development tools which are specific
#		to the target architecture.
#
# WORLD		(Cross built) Our ultimate buildworld, using only BTOOLS and
#		CTOOLS.
#
# MACHINE_PLATFORM	Platform Architecture we are building on
# MACHINE		Machine Architecture (usually the same as MACHINE_ARCH)
# MACHINE_ARCH		CPU Architecture we are building on
#
# TARGET_PLATFORM 	Platform Architecture we are building for
# TARGET		Machine Architecture we are building for
# TARGET_ARCH		CPU Architecture we are building for
#
BTOOLSDEST=	${DESTDIRBASE}/btools_${MACHINE_ARCH}
CTOOLSDEST=	${DESTDIRBASE}/ctools_${MACHINE_ARCH}_${TARGET_ARCH}
WORLDDEST=	${DESTDIRBASE}/world_${TARGET_ARCH}

# The bootstrap-tools path is used by the bootstrap-tools, build-tools, and
# cross-tools stages to augment the existing command path to access newer
# versions of certain utilities that the cross-tools stage might expect.
#
BTOOLSPATH= ${BTOOLSDEST}/usr/sbin:${BTOOLSDEST}/usr/bin:${BTOOLSDEST}/sbin:${BTOOLSDEST}/bin

# The cross-tools path containing the cross-tools to cross build the
# ultimate world.
#
CTOOLSPATH= ${CTOOLSDEST}/usr/sbin:${CTOOLSDEST}/usr/bin:${CTOOLSDEST}/sbin:${CTOOLSDEST}/bin

# The strict temporary command path contains all binaries required
# by the buildworld system after the cross-tools stage.
#
# NOTE: Append '/usr/local/bin:/usr/local/sbin' to support external compilers.
#       See compilers.conf(5) man page for more info.
#
STRICTTMPPATH= ${CTOOLSPATH}:${BTOOLSPATH}:/usr/local/bin:/usr/local/sbin

TMPDIR?=	/tmp
TMPPID!=	echo $$$$

#
# Building a world goes through the following stages
#
# 1. bootstrap-tool stage [BMAKE]
#	This stage is responsible for creating programs that
#	are needed for backward compatibility reasons. They
#	are not built as cross-tools.
# 2. build-tool stage [TMAKE]
#	This stage is responsible for creating the object
#	tree and building any tools that are needed during
#	the build process.
# 3. cross-tool stage [XMAKE]
#	This stage is responsible for creating any tools that
#	are needed for cross-builds. A cross-compiler is one
#	of them.
# 4. world stage [WMAKE]
#	This stage actually builds the world.
# 5. install stage (optional) [IMAKE]
#	This stage installs a previously built world.
#
# In all cases we must carefully adjust the environment so the proper
# tools and header files are used.
#
# NOTE: The M4 environment variable is used by the [f]lex binary to
#	override the location of the 'm4' binary.  The override is
#	needed for certain buildworld version transitions, specifically
#	past a certain point in 3.3 because the older /usr/bin/m4 will
#	generate output that will blow up the newer [f]lex/yacc/bison
#	utilities.
#

# bootstrap-tool stage
#
BMAKEENV=	MAKEOBJDIRPREFIX=${BTOOLSDEST} \
		OBJTREE=${OBJTREE} \
		DESTDIR=${BTOOLSDEST} \
		LC_ALL=C \
		_SHLIBDIRPREFIX=${BTOOLSDEST} \
		PATH=${BTOOLSPATH}:${PATH} \
		M4=${BTOOLSDEST}/usr/bin/m4 \
		INSTALL="sh ${.CURDIR}/tools/install.sh"

BMAKE=		${BMAKEENV} make -f Makefile.inc1 -DBOOTSTRAPPING \
		-DNOMAN -DNOPIC -DNOPROFILE -DNOSHARED \
		-DNO_WERROR -DNO_NLS -DSYSBUILD

# build-tool stage
#
TMAKEENV=	MAKEOBJDIRPREFIX=${BTOOLSDEST} \
		OBJTREE=${OBJTREE} \
		DESTDIR= \
		LC_ALL=C \
		PATH=${BTOOLSPATH}:${PATH} \
		M4=${BTOOLSDEST}/usr/bin/m4 \
		INSTALL="sh ${.CURDIR}/tools/install.sh"

TMAKE=		${TMAKEENV} make -f Makefile.inc1 -DBOOTSTRAPPING \
		-DNOSHARED -DSYSBUILD

# cross-tool stage
#
# note: TOOLS_PREFIX points to the obj root holding the cross
#	compiler binaries, while USRDATA_PREFIX points to the obj root
#	holding the target environment (and also determines where cross-built
#	libraries, crt*.o, and include files are installed).
#
XMAKEENV=	MAKEOBJDIRPREFIX=${CTOOLSDEST} \
		OBJTREE=${OBJTREE} \
		DESTDIR=${CTOOLSDEST} \
		LC_ALL=C \
		_SHLIBDIRPREFIX=${CTOOLSDEST} \
		INSTALL="sh ${.CURDIR}/tools/install.sh" \
		TOOLS_PREFIX=${CTOOLSDEST} \
		USRDATA_PREFIX=${WORLDDEST} \
		SELECT_LINKER=${WORLD_LDVER} \
		M4=${BTOOLSDEST}/usr/bin/m4 \
		PATH=${BTOOLSPATH}:${PATH}

XMAKE=		${XMAKEENV} make -f Makefile.inc1 -DNO_GDB \
		-DBOOTSTRAPPING -DNOMAN -DNOSHARED -DSYSBUILD

# world stage, note the strict path and note that TOOLS_PREFIX is left
# unset and USRDATA_PREFIX (which defaults to TOOLS_PREFIX) is set to empty,
# which is primarily for the compiler so it targets / (e.g. /usr/<blah>)
# for both binary and library paths, even though it is being compiled to
# WORLDDEST.  None of the programs in the world stage are ever actually
# executed during the buildworld/installworld.
#
CROSSENV=	MAKEOBJDIRPREFIX=${WORLDDEST} \
		OBJTREE=${OBJTREE} \
		MACHINE_ARCH=${TARGET_ARCH} \
		MACHINE=${TARGET} \
		MACHINE_PLATFORM=${TARGET_PLATFORM} \
		LC_ALL=C \
		OBJFORMAT_PATH=${CTOOLSDEST} \
		HOST_CCVER=${HOST_CCVER} \
		CCVER=${WORLD_CCVER} \
		LDVER=${WORLD_LDVER} \
		BINUTILSVER=${WORLD_BINUTILSVER}

WMAKEENV=	${CROSSENV} \
		WORLDBUILD=1 \
		DESTDIR=${WORLDDEST} \
		_SHLIBDIRPREFIX=${WORLDDEST} \
		INSTALL="sh ${.CURDIR}/tools/install.sh" \
		M4=${BTOOLSDEST}/usr/bin/m4 \
		PATH=${STRICTTMPPATH}

WMAKE=		${WMAKEENV} make -f Makefile.inc1 -DSYSBUILD

# install stage
#
IMAKEENV=	${CROSSENV} \
		PATH=${STRICTTMPPATH}
IMAKE=		${IMAKEENV} make -f Makefile.inc1 -DSYSBUILD

# kernel stage
#
KMAKEENV=	${WMAKEENV}

# buildworld
#
# Attempt to rebuild the entire system, with reasonable chance of
# success, regardless of how old your existing system is.
#
_worldtmp: _cleantmp _mtreetmp
.ORDER: _cleantmp _mtreetmp

_cleantmp:
.if !defined(NOCLEAN)
	-chflags -R noschg ${BTOOLSDEST} ${CTOOLSDEST} ${WORLDDEST}
	rm -rf ${BTOOLSDEST} ${CTOOLSDEST} ${WORLDDEST}
.else
	# XXX - These two can depend on any header file.
	rm -f ${OBJTREE}${.CURDIR}/usr.bin/kdump/ioctl.c
	rm -f ${OBJTREE}${.CURDIR}/usr.bin/truss/ioctl.c
.endif

_mtreetmp:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> Rebuilding the temporary build tree"
	@echo "--------------------------------------------------------------"
	mkdir -p ${DESTDIRBASE} ${BTOOLSDEST} ${CTOOLSDEST} ${WORLDDEST}
.for _dir in ${WORLDDEST} ${BTOOLSDEST} ${CTOOLSDEST}
	mtree -deU -f ${.CURDIR}/etc/mtree/BSD.root.dist	\
		-p ${_dir}/  > /dev/null
	mtree -deU -f ${.CURDIR}/etc/mtree/BSD.usr.dist		\
		-p ${_dir}/usr > /dev/null
.endfor
	mtree -deU -f ${.CURDIR}/etc/mtree/BSD.include.dist	\
		-p ${WORLDDEST}/usr/include > /dev/null
	${LN} -sf ${.CURDIR}/sys ${WORLDDEST}

_bwcleanup: umountports
	mkdir -p ${DESTDIRBASE}
	chflags -R noschg ${DESTDIRBASE}
	rm -rxf ${DESTDIRBASE}

_bwinit:
	@echo "--------------------------------------------------------------"
	@echo ">>> starting buildworld target"
	@echo "--------------------------------------------------------------"
_bootstrap-tools:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 1: bootstrap tools"
	@echo "--------------------------------------------------------------"
	cd ${.CURDIR}; ${BMAKE} bootstrap-tools
_cleanobj:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 2a: cleaning up the object tree"
	@echo "--------------------------------------------------------------"
	cd ${.CURDIR}; ${WMAKE} ${CLEANDIR:S/^/par-/}
_obj:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 2b: rebuilding the object tree"
	@echo "--------------------------------------------------------------"
	cd ${.CURDIR}; ${WMAKE} par-obj
_build-tools:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 2c: build tools"
	@echo "--------------------------------------------------------------"
	cd ${.CURDIR}; ${TMAKE} build-tools
_cross-tools:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 3: cross tools"
	@echo "--------------------------------------------------------------"
	cd ${.CURDIR}; ${XMAKE} cross-tools
_includes:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 4a: populating ${WORLDDEST}/usr/include"
	@echo "--------------------------------------------------------------"
	cd ${.CURDIR}; ${WMAKE} SHARED=symlinks par-includes
_libraries:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 4b: building libraries"
	@echo "--------------------------------------------------------------"
	cd ${.CURDIR}; ${WMAKE} -DNOHTML -DNOMAN -DNOFSCHG libraries
_depend:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 4c: make dependencies"
	@echo "--------------------------------------------------------------"
	cd ${.CURDIR}; ${WMAKE} par-depend
everything:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 4d: building everything"
	@echo "--------------------------------------------------------------"
	cd ${.CURDIR}; ${WMAKE} all
_initrd:
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> stage 5: building rescue and initrd"
	@echo "--------------------------------------------------------------"
.if !defined(NO_INITRD)
	cd ${.CURDIR}/initrd; ${WMAKEENV} make all
.endif
_bwdone:
	@echo "--------------------------------------------------------------"
	@echo ">>> buildworld target complete"
	@echo "--------------------------------------------------------------"
_qwinit:
	@echo "--------------------------------------------------------------"
	@echo ">>> starting quickworld target"
	@echo "--------------------------------------------------------------"
_qwdone:
	@echo "--------------------------------------------------------------"
	@echo ">>> quickworld target complete"
	@echo "--------------------------------------------------------------"
_iwinit:
	@echo "--------------------------------------------------------------"
	@echo ">>> starting installworld target"
	@echo "--------------------------------------------------------------"

# note: buildworld no longer depends on _cleanobj because we rm -rf the
# entire object tree and built the bootstrap tools in a different location.
#
# buildworld	- build everything from scratch
# quickworld	- skip the bootstrap, build, and cross-build steps
# realquickworld - skip the bootstrap, build, crossbuild, and depend step.
#
# note: we include _obj in realquickworld to prevent accidental creation
# of files in /usr/src.

WMAKE_TGTS=
.if !defined(SUBDIR_OVERRIDE)
WMAKE_TGTS+=	_worldtmp _bootstrap-tools
.endif
WMAKE_TGTS+=	_obj _build-tools
.if !defined(SUBDIR_OVERRIDE)
WMAKE_TGTS+=	_cross-tools
.endif
WMAKE_TGTS+=	_includes _libraries _depend everything _initrd

.if defined(WMAKE_TGTS_OVERRIDE)
SUBDIR=
WMAKE_TGTS=	${WMAKE_TGTS_OVERRIDE}
.endif

QMAKE_TGTS=	_mtreetmp _obj _includes _libraries _depend everything _initrd

buildworld: _bwinit ${WMAKE_TGTS} _bwdone

quickworld: _qwinit ${QMAKE_TGTS} _qwdone

realquickworld: _qwinit _mtreetmp _obj _includes _libraries everything _qwdone

crossworld: _worldtmp _bootstrap-tools _obj _build-tools _cross-tools

.ORDER: umountports mountports
GENLOGDIR=	/usr/obj${.CURDIR}

# Build a chroot environment for buildports
#
# The chroot environment is built by doing a fresh make installworld
# and make distribution, mounting expected filesystems, doing the
# initial ldconfig setup, and copying resolv.conf to hopefully get
# a working network.  Without these elements, various parts of dsynth
# and the pkg system will bail.
#
buildportschroot: umountports
	mkdir -p ${WORLDDEST}/chroot
	mkdir -p ${WORLDDEST}/chroot/usr/src
	@echo "building chroot, logfile in: ${GENLOGDIR}/chroot.out"
	@(cd ${.CURDIR}; ${MAKE} -j `sysctl -n hw.ncpu` installworld DESTDIR=${WORLDDEST}/chroot > ${GENLOGDIR}/chroot.out 2>&1)
	@(cd ${.CURDIR}/etc; ${MAKE} -j `sysctl -n hw.ncpu` distribution DESTDIR=${WORLDDEST}/chroot >> ${GENLOGDIR}/chroot.out 2>&1)
	@echo "mounting procfs, devfs, tmpfs in chroot"
	@(cd ${.CURDIR}; ${MAKE} mountports >> ${GENLOGDIR}/chroot.out 2>&1)
	chroot ${WORLDDEST}/chroot /bin/csh -c "cd /etc/rc.d; sh ldconfig start"
	cp /etc/resolv.conf ${WORLDDEST}/chroot/etc/
	@(cd ${.CURDIR}; ${MAKE} umountports >> ${GENLOGDIR}/chroot.out 2>&1)

# Build dragonfly/base dports using the chroot environment setup by
# buildportschroot.
#
# NOTE: The real system's /usr/distfiles.base is shared with the chroot and
#	dsynth will fetch source dists as necessary.  If the real system
#	is not yet fully up-to-date, it might not have its /usr/distfiles.base
#	yet though so create it if necessary.
#
buildports: umountports mountports
	mkdir -p ${WORLDDEST}/chroot
	mkdir -p ${WORLDDEST}/chroot/build/synth
	mkdir -p ${WORLDDEST}/chroot/build/synth/live_packages
	mkdir -p ${WORLDDEST}/chroot/build/synth/logs
	mkdir -p ${WORLDDEST}/chroot/build/synth/options
	mkdir -p ${WORLDDEST}/chroot/build/synth/build
	mkdir -p /usr/distfiles.base
	cp ${.CURDIR}/dports.base/dsynth.ini ${WORLDDEST}/chroot/build/synth/
	cp ${.CURDIR}/dports.base/pkg.conf ${WORLDDEST}/chroot/build/
	@echo "dsynth logs will be stored in ${WORLDDEST}/chroot/build/synth/logs"
	@echo "pkg file path: file:///${WORLDDEST}/chroot/build/synth/live_packages/"
	chroot ${WORLDDEST}/chroot dsynth -g -SS -y -C /build/synth build dragonfly/base
	@(cd ${.CURDIR}; ${MAKE} umountports)

# Install base system ports (does not require the chroot but does require
# the dports stuff that was built in the chroot)
#
# NOTE: At the moment, the pkg install command may require interactivity,
#	do not redirect.  We have to adjust pkg.conf's paths because
#	we are installing relative to the real root and not the chroot.
#
installports: umountports mountports
	cd ${WORLDDEST} && tar xvzpf ${WORLDDEST}/chroot/build/synth/live_packages/All/pkg-*.pkg > /dev/null 2>&1
	cat ${.CURDIR}/dports.base/pkg.conf | sed -e 's#/build#${WORLDDEST}/chroot/build#' > ${WORLDDEST}/chroot/build/pkg.conf
	${WORLDDEST}/usr/local/sbin/pkg-static --rootdir ${DESTDIR}/ -R ${WORLDDEST}/chroot/build install -y dragonfly-base
	@(cd ${.CURDIR}; ${MAKE} umountports)

.ORDER: build-all install-all

mountports:
	@echo "mounting for ports chroot"
	mount_devfs dummy ${WORLDDEST}/chroot/dev
	mount_procfs dummy ${WORLDDEST}/chroot/proc
	mount_tmpfs dummy ${WORLDDEST}/chroot/tmp
	mount_tmpfs dummy ${WORLDDEST}/chroot/var/tmp
	mount_null ${.CURDIR} ${WORLDDEST}/chroot/usr/src
	mount_null ${DPORTSBASE} ${WORLDDEST}/chroot/usr/src/dports.base
	mkdir -p ${WORLDDEST}/chroot/usr/src/dports.base/dragonfly
	mount_null ${.CURDIR}/dports.base/dragonfly ${WORLDDEST}/chroot/usr/src/dports.base/dragonfly
	mount_null /usr/distfiles.base ${WORLDDEST}/chroot/usr/distfiles.base

# Cleanup the chroot's mounts but otherwise leave it intact
#
# Strange make lines avoid junk reporting to stderr
#
umountports:
	@echo "cleanup any old dsynth mounts (if any)"
	-@chroot ${WORLDDEST}/chroot dsynth -SS -y -C /build/synth cleanup > /dev/null 2>&1 || true
	@echo "unmount old chroot devfs, procfs, etc (if any)"
	-@umount -f ${WORLDDEST}/chroot/usr/distfiles.base > /dev/null 2>&1 || true
	-@umount -f ${WORLDDEST}/chroot/usr/src/dports.base/dragonfly > /dev/null 2>&1 || true
	-@umount -f ${WORLDDEST}/chroot/usr/src/dports.base > /dev/null 2>&1 || true
	-@umount -f ${WORLDDEST}/chroot/usr/src > /dev/null 2>&1 || true
	-@umount -f ${WORLDDEST}/chroot/dev > /dev/null 2>&1 || true
	-@umount -f ${WORLDDEST}/chroot/proc > /dev/null 2>&1 || true
	-@umount -f ${WORLDDEST}/chroot/tmp > /dev/null 2>&1 || true
	-@umount -f ${WORLDDEST}/chroot/var/tmp > /dev/null 2>&1 || true

# build-all
#
# build
build-all: _bwcleanup
	@echo "Building world, log file in ${GENLOGDIR}/bw.out"
	@mkdir -p ${GENLOGDIR}
	@(cd ${.CURDIR}; ${MAKE} -j `sysctl -n hw.ncpu` buildworld > ${GENLOGDIR}/bw.out 2>&1)
	@sync
	@echo "Building kernel, log file in ${GENLOGDIR}/bk.out"
	@(cd ${.CURDIR}; ${MAKE} -j `sysctl -n hw.ncpu` buildkernel > ${GENLOGDIR}/bk.out 2>&1)
	@echo "build-all main buildworld and buildkernel completed ok"
	@sync
.if defined(WITH_DPORTS)
	@echo "Building dragonfly/base dports, logs in ${GENLOGDIR}/bp.out"
	@echo "IF YOU INTERRUPT THE MAKE, THEN RUN make umountports"
	@(cd ${.CURDIR}; ${MAKE} -j `sysctl -n hw.ncpu` buildportschroot > ${GENLOGDIR}/bp.out 2>&1)
	@(cd ${.CURDIR}; ${MAKE} -j `sysctl -n hw.ncpu` buildports > ${GENLOGDIR}/bp.out 2>&1)
.endif

install-all:
	@echo "Installing kernel, log file in ${GENLOGDIR}/bk.out"
	@mkdir -p ${GENLOGDIR}
	@(cd ${.CURDIR}; ${MAKE} -j 1 installkernel >> ${GENLOGDIR}/bk.out 2>&1)
	@sync
	@echo "Installing world, log file in ${GENLOGDIR}/bw.out"
	@(cd ${.CURDIR}; ${MAKE} -j 1 installworld >> ${GENLOGDIR}/bw.out 2>&1)
	@sync
	@echo "Upgrading world"
	@(cd ${.CURDIR}; ${MAKE} -j 1 upgrade >> ${GENLOGDIR}/bw.out 2>&1)
	@sync
	@echo "install-all main world and kernel completed ok."
.if defined(WITH_DPORTS)
	@echo "Installing dragonfly/base dports, log file in ${GENLOGDIR}/bp.out"
	@(cd ${.CURDIR}; ${MAKE} -j `sysctl -n hw.ncpu` installports)
	@(cd ${.CURDIR}; ${MAKE} -j `sysctl -n hw.ncpu` umountports >> ${GENLOGDIR}/bp.out 2>&1)
.endif
	@echo "reboot recommended and after that, "
	@echo "when doing a major upgrade, 'pkg upgrade -f' after rebooting"

.ORDER: _bwinit ${WMAKE_TGTS} _bwdone
.ORDER: _obj _includes
.ORDER: _qwinit _mtreetmp _obj
.ORDER: _bwcleanup _bwinit
.ORDER: installcheck backupworld-auto
.ORDER: everything _qwdone


# installcheck
#
# Checks to be sure system is ready for installworld
#
installcheck: _iwinit
.if !defined(OVERRIDE_CHECKS)
.if !defined(DESTDIR) || ${DESTDIR} == "" || ${DESTDIR} == "/"
	@case `uname -r` in \
	    1.2*|1.3-*|1.3.*|1.4.*|1.5.0-*|1.5.1-*|1.5.2-*|1.5.3-*) \
		echo "You must upgrade your kernel to at least 1.5.4" \
		     "and reboot before you can safely installworld," \
		     "due to libc/system call ABI changes."; \
		/usr/bin/false; \
	esac
	@case `uname -r` in \
	    1.*|2.*|3.0*|3.1*|3.2*|3.3*|3.4*|3.5*|3.6*) \
		echo "The system is too old for a normal installworld," \
		     "you need to use 'installworld-force'."; \
		/usr/bin/false; \
	esac
.endif
.endif

# installworld
#
# Backs up the current world if ${AUTO_BACKUP} is writable.
# Installs everything compiled by a 'buildworld'.
#
installworld: installcheck
.if !defined(NO_BACKUP)
	-@mkdir -p ${AUTO_BACKUP} > /dev/null 2>&1
	@cd ${.CURDIR}; \
	    (touch ${AUTO_BACKUP}/.updating > /dev/null 2>&1 && \
	     ${IMAKE} backupworld-auto) || \
	    echo "Cannot write to ${AUTO_BACKUP} - world not backed up"
.endif
	cd ${.CURDIR}; ${IMAKE} re${.TARGET:S/world$//}
	${INSTALL} -o root -g wheel -m 644 ${.CURDIR}/Makefile_upgrade.inc \
	    ${DESTDIR}/etc/upgrade/
	cd ${.CURDIR}; ${IMAKE} -DWORLDINSTALL os-release
.if !defined(NO_INITRD)
	cd ${.CURDIR}; ${IMAKE} -DWORLDINSTALL initrd
.endif
	sync
	@echo "--------------------------------------------------------------"
	@echo ">>> installworld target complete"
	@echo "--------------------------------------------------------------"

os-release:
	@echo "NAME=DragonFly" > ${DESTDIR}/etc/os-release
	@echo "VERSION=${OSREL}-SYNTH" >> ${DESTDIR}/etc/os-release
	@echo "VERSION_ID=${OSREL}" >> ${DESTDIR}/etc/os-release
	@echo "ID=dragonfly" >> ${DESTDIR}/etc/os-release
	@echo "ANSI_COLOR=\"0;32\"" >> ${DESTDIR}/etc/os-release
	@echo "PRETTY_NAME=\"DragonFlyBSD ${OSREL}-SYNTH\"" >> ${DESTDIR}/etc/os-release
	@echo "CPE_NAME=\"cpe:/o:dragonflybsd:dragonfly:${OSREL}\"" >> ${DESTDIR}/etc/os-release
	@echo "SUPPORT_URL=\"http://chat.efnet.org:9090/?nick=dflynick&channels=%23dragonflybsd&Login=Login\"" >> ${DESTDIR}/etc/os-release
	@echo "HOME_URL=\"https://www.dragonflybsd.org/\"" >> ${DESTDIR}/etc/os-release
	@echo "BUG_REPORT_URL=\"https://bugs.dragonflybsd.org/\"" >> ${DESTDIR}/etc/os-release
	@echo "MACHINE_ARCH=${MACHINE_ARCH}" >> ${DESTDIR}/etc/os-release
	@echo "MACHINE=${MACHINE}" >> ${DESTDIR}/etc/os-release
	@echo "DFLYVERSION=${DFLYVERSION}" >> ${DESTDIR}/etc/os-release

installworld-force:
	@echo "Doing a forced installworld.  This will install to a temporary directory,"
	@echo "then copy the main binaries and libraries with a static cpdup to ${DESTDIR}/"
	@echo "and finally will issue a normal installworld."
	@echo
	@echo "Starting in 5 seconds.  ^C to abort."
	@echo
	sleep 1
	rm -rf /usr/obj/temp > /dev/null 2>&1 || chflags -R noschg /usr/obj/temp
	rm -rf /usr/obj/temp
	mkdir -p /usr/obj/temp/cpdup/bin
	(cd ${.CURDIR}/bin/cpdup; \
		make clean && \
		make obj && \
		make clean && \
		make CFLAGS=-static all install DESTDIR=/usr/obj/temp/cpdup NOMAN=TRUE)
	@echo "XXXXXXXXX Installing to temporary XXXXXXXXX"
	@sleep 1
	(cd ${.CURDIR}; ${MAKE} installworld DESTDIR=/usr/obj/temp > /dev/null 2>&1)
	@echo "XXXXXXXXX Blasting binaries and libraries XXXXXXXXX"
	@sleep 1
	/usr/obj/temp/cpdup/bin/cpdup -i0 /usr/obj/temp/bin /bin
	/usr/obj/temp/cpdup/bin/cpdup -i0 /usr/obj/temp/sbin /sbin
	/usr/obj/temp/cpdup/bin/cpdup -i0 /usr/obj/temp/lib /lib
	/usr/obj/temp/cpdup/bin/cpdup -i0 /usr/obj/temp/usr/bin /usr/bin
	/usr/obj/temp/cpdup/bin/cpdup -i0 /usr/obj/temp/usr/sbin /usr/sbin
	/usr/obj/temp/cpdup/bin/cpdup -i0 /usr/obj/temp/usr/lib /usr/lib
	/usr/obj/temp/cpdup/bin/cpdup -i0 /usr/obj/temp/libexec /libexec
	/usr/obj/temp/cpdup/bin/cpdup -i0 /usr/obj/temp/usr/libexec /usr/libexec
	@echo "XXXXXXXXX Doing final installworld XXXXXXXX"
	sleep 5
	(cd ${.CURDIR}; ${MAKE} installworld OVERRIDE_CHECKS=TRUE)
	(cd ${.CURDIR}; ${MAKE} upgrade OVERRIDE_CHECKS=TRUE)
.if !defined(NO_INITRD)
	(cd ${.CURDIR}; ${MAKE} initrd)
.endif

# reinstall
#
# If you have a build server, you can NFS mount the source and obj directories
# and do a 'make reinstall' on the *client* to install new binaries from the
# most recent server build.
#
reinstall:
	@echo "--------------------------------------------------------------"
	@echo ">>> Making hierarchy"
	@echo "--------------------------------------------------------------"
	cd ${.CURDIR}; make -f Makefile.inc1 hierarchy
	@echo
	@echo "--------------------------------------------------------------"
	@echo ">>> Installing everything"
	@echo "--------------------------------------------------------------"
	cd ${.CURDIR}; make -f Makefile.inc1 install

# initrd
#
# Install the rescue tools and the initrd image built by 'buildworld'.
#
initrd: .PHONY
	(cd ${.CURDIR}/initrd; ${IMAKEENV} make install)


# buildkernel, nativekernel, quickkernel, realquickkernel, and installkernel
#
# Which kernels to build and/or install is specified by setting
# KERNCONF. If not defined an X86_64_GENERIC kernel is built/installed.
# Only the existing (depending TARGET) config files are used
# for building kernels and only the first of these is designated
# as the one being installed.
#
# You can specify INSTALLSTRIPPED=1 if you wish the installed
# kernel and modules to be stripped of its debug info (required
# symbols are left intact).  You can specify INSTALLSTRIPPEDMODULES
# if you only want to strip the modules of their debug info.  These
# only apply if you have DEBUG=-g in your kernel config or make line.
#
# Note that we have to use TARGET instead of TARGET_ARCH when
# we're in kernel-land. Since only TARGET_ARCH is (expected) to
# be set to cross-build, we have to make sure TARGET is set
# properly.

.if !defined(KERNCONF) && defined(KERNEL)
KERNCONF=	${KERNEL}
KERNWARN=	yes
.else
# XXX makeshift fix to build the right kernel for the (target) architecture
# We should configure this in the platform files somehow
.if ${TARGET_ARCH} == "x86_64"
KERNCONF?=	X86_64_GENERIC
.endif
.endif
INSTKERNNAME?=	kernel

KRNLSRCDIR=	${.CURDIR}/sys
KRNLCONFDIR=	${KRNLSRCDIR}/config
KRNLOBJDIR=	${OBJTREE}${KRNLSRCDIR}
KERNCONFDIR?=	${KRNLCONFDIR}

BUILDKERNELS=
INSTALLKERNEL=
.for _kernel in ${KERNCONF}
.if exists(${KERNCONFDIR}/${_kernel})
BUILDKERNELS+=	${_kernel}
.if empty(INSTALLKERNEL)
INSTALLKERNEL= ${_kernel}
.endif
.endif
.endfor

# kernel version numbers survive rm -rf
#
.for _kernel in ${BUILDKERNELS}
.if exists(${KRNLOBJDIR}/${_kernel}/version)
KERNEL_VERSION_${_kernel} != cat ${KRNLOBJDIR}/${_kernel}/version
.endif
.endfor

# buildkernel
#
# Builds all kernels defined by BUILDKERNELS.
#
bk_tools:
	@if [ ! -f ${WORLDDEST}/.libraries_done ]; then \
	    echo "You must buildworld before buildkernel.  If you wish"; \
	    echo "to build a kernel using native tools, config it manually"; \
	    echo "or use the nativekernel target if you are in a rush"; \
	    /usr/bin/false; \
	fi

maybe_bk_tools:
.for _kernel in ${BUILDKERNELS}
	@if [ ! -f ${KRNLOBJDIR}/${_kernel}/.nativekernel_run ]; then \
	    if [ ! -f ${WORLDDEST}/.libraries_done ]; then \
		echo "The kernel was built using buildworld tools which no" ; \
		echo "longer appear to exist, (real)quickkernel failed!" ; \
		/usr/bin/false; \
	    fi; \
	fi
.endfor

bk_build_list:
.if empty(BUILDKERNELS)
	@echo ">>> ERROR: Missing kernel configuration file(s)."
	@echo ">>> ${KERNCONF} not found in ${KERNCONFDIR}."
	@false
.endif

bk_kernwarn:
.if defined(KERNWARN)
	@echo "--------------------------------------------------------------"
	@echo ">>> WARNING: KERNEL= setting should be changed to KERNCONF="
	@echo "--------------------------------------------------------------"
	@sleep 3
.endif
	@echo

# The buildkernel target rebuilds the specified kernels from scratch
# using the crossbuild tools generated by the last buildworld.  It is
# the safest (but also the most time consuming) way to build a new kernel.
#
buildkernel:	bk_tools bk_build_list bk_kernwarn
.for _kernel in ${BUILDKERNELS}
	@echo "--------------------------------------------------------------"
	@echo ">>> Kernel build for ${_kernel} started on `LC_ALL=C date`"
	@echo "--------------------------------------------------------------"
	@echo "===> ${_kernel}"
.if !defined(NOCLEAN) && !defined(NO_KERNELCLEAN)
	rm -rf ${KRNLOBJDIR}/${_kernel}
.else
	@if [ -f ${KRNLOBJDIR}/${_kernel}/.nativekernel_run ]; then \
		echo "YOU ARE REBUILDING WITH BUILDKERNEL, REMOVING OLD NATIVEKERNEL BUILD"; \
		rm -rf ${KRNLOBJDIR}/${_kernel}; fi
.endif
	mkdir -p ${KRNLOBJDIR}
.if !defined(NO_KERNELCONFIG)
	cd ${KRNLCONFDIR}; \
		PATH=${STRICTTMPPATH} \
		    config ${CONFIGARGS} -d ${KRNLOBJDIR}/${_kernel} \
			${KERNCONFDIR}/${_kernel}
.endif
.if !defined(NOCLEAN) && !defined(NO_KERNELCLEAN) && defined(KERNEL_VERSION_${_kernel})
	echo ${KERNEL_VERSION_${_kernel}} > ${KRNLOBJDIR}/${_kernel}/version
.endif
	touch ${KRNLOBJDIR}/${_kernel}/.buildkernel_run
.if !defined(NO_KERNELDEPEND)
	cd ${KRNLOBJDIR}/${_kernel}; \
	    ${KMAKEENV} make KERNEL=${INSTKERNNAME} depend
.endif
	cd ${KRNLOBJDIR}/${_kernel}; \
	    ${KMAKEENV} make KERNEL=${INSTKERNNAME} all
	@echo "--------------------------------------------------------------"
	@echo ">>> Kernel build for ${_kernel} completed on `LC_ALL=C date`"
	@echo "--------------------------------------------------------------"
.endfor

# The nativekernel target rebuilds the specified kernels from scratch
# using the system's standard compiler rather than using the crossbuild
# tools generated by the last buildworld.  This is fairly safe if your
# system is reasonable up-to-date.
#
nativekernel:	bk_build_list bk_kernwarn
.for _kernel in ${BUILDKERNELS}
	@echo "--------------------------------------------------------------"
	@echo ">>> Kernel build for ${_kernel} started on `LC_ALL=C date`"
	@echo "--------------------------------------------------------------"
	@echo "===> ${_kernel}"
.if !defined(NOCLEAN) && !defined(NO_KERNELCLEAN)
	rm -rf ${KRNLOBJDIR}/${_kernel}
.else
	@if [ -f ${KRNLOBJDIR}/${_kernel}/.buildkernel_run ]; then \
		echo "YOU ARE REBUILDING WITH NATIVEKERNEL, REMOVING OLD BUILDKERNEL BUILD"; \
		rm -rf ${KRNLOBJDIR}/${_kernel}; fi
.endif
	mkdir -p ${KRNLOBJDIR}
.if !defined(NO_KERNELCONFIG)
	cd ${KRNLCONFDIR}; \
		    config ${CONFIGARGS} -d ${KRNLOBJDIR}/${_kernel} \
			${KERNCONFDIR}/${_kernel}
.endif
.if !defined(NOCLEAN) && !defined(NO_KERNELCLEAN) && defined(KERNEL_VERSION_${_kernel})
	echo ${KERNEL_VERSION_${_kernel}} > ${KRNLOBJDIR}/${_kernel}/version
.endif
	touch ${KRNLOBJDIR}/${_kernel}/.nativekernel_run
.if !defined(NO_KERNELDEPEND)
	cd ${KRNLOBJDIR}/${_kernel}; \
	    make KERNEL=${INSTKERNNAME} depend
.endif
	cd ${KRNLOBJDIR}/${_kernel}; \
	    make KERNEL=${INSTKERNNAME} all
	@echo "--------------------------------------------------------------"
	@echo ">>> Kernel build for ${_kernel} completed on `LC_ALL=C date`"
	@echo "--------------------------------------------------------------"
.endfor

# The (real)quickkernel target rebuilds the specified kernels as quickly
# as possible.  It will use the native tools or the buildworld cross tools
# based on whether the kernel was originally generated via buildkernel or
# nativekernel.  Config is rerun but the object hierarchy is not rebuilt.
# realquickkernel skips the depend step (analogous to realquickworld).
#
quickkernel realquickkernel:	maybe_bk_tools bk_build_list bk_kernwarn
.for _kernel in ${BUILDKERNELS}
	@echo "--------------------------------------------------------------"
	@echo ">>> Kernel build for ${_kernel} started on `LC_ALL=C date`"
	@echo "--------------------------------------------------------------"
	@echo "===> ${_kernel}"
.if exists(${KRNLOBJDIR}/${_kernel}/.buildkernel_run)
.if !defined(NO_KERNELCONFIG)
	cd ${KRNLCONFDIR}; \
		PATH=${STRICTTMPPATH} \
		    config ${CONFIGARGS} -d ${KRNLOBJDIR}/${_kernel} \
			${KERNCONFDIR}/${_kernel}
.endif
.if !defined(NO_KERNELDEPEND) && !make(realquickkernel)
	cd ${KRNLOBJDIR}/${_kernel}; \
	    ${KMAKEENV} make KERNEL=${INSTKERNNAME} depend
.endif
	cd ${KRNLOBJDIR}/${_kernel}; \
	    ${KMAKEENV} make KERNEL=${INSTKERNNAME} all
.else
.if !defined(NO_KERNELCONFIG)
	cd ${KRNLCONFDIR}; \
	    config ${CONFIGARGS} -d ${KRNLOBJDIR}/${_kernel} \
		${KERNCONFDIR}/${_kernel}
.endif
.if !defined(NO_KERNELDEPEND) && !make(realquickkernel)
	cd ${KRNLOBJDIR}/${_kernel}; \
	    make KERNEL=${INSTKERNNAME} depend
.endif
	cd ${KRNLOBJDIR}/${_kernel}; \
	    make KERNEL=${INSTKERNNAME} all
.endif
	@echo "--------------------------------------------------------------"
	@echo ">>> Kernel build for ${_kernel} completed on `LC_ALL=C date`"
	@echo "--------------------------------------------------------------"
.endfor


# installkernel
#
# Install the kernel defined by INSTALLKERNEL
#
installkernel reinstallkernel:
	@echo "--------------------------------------------------------------"
	@echo ">>> Kernel install for ${INSTALLKERNEL} started on `LC_ALL=C date`"
	@echo "--------------------------------------------------------------"
.if exists(${KRNLOBJDIR}/${INSTALLKERNEL}/.buildkernel_run)
	cd ${KRNLOBJDIR}/${INSTALLKERNEL}; \
	    ${IMAKEENV} make KERNEL=${INSTKERNNAME} ${.TARGET:S/kernel$//}
.else
	cd ${KRNLOBJDIR}/${INSTALLKERNEL}; \
	    make KERNEL=${INSTKERNNAME} ${.TARGET:S/kernel$//}
.endif
	@echo "--------------------------------------------------------------"
	@echo ">>> Kernel install for ${INSTALLKERNEL} completed on `LC_ALL=C date`"
	@echo "--------------------------------------------------------------"


# ------------------------------------------------------------------------
#
# From here onwards are utility targets used by the 'make world' and
# related targets.  If your 'world' breaks, you may like to try to fix
# the problem and manually run the following targets to attempt to
# complete the build.  Beware, this is *not* guaranteed to work, you
# need to have a pretty good grip on the current state of the system
# to attempt to manually finish it.  If in doubt, 'make world' again.
#

# bootstrap-tools: Build all tools required to build all tools.  Note that
# order is important in a number of cases and also note that the bootstrap
# and build tools stages have access to earlier binaries they themselves
# had generated.
#
# [x]install:	dependencies on various new install features
# rpcgen:	old rpcgen used a hardwired cpp path, newer OBJFORMAT_PATH
#		envs are not compatible with older objformat binaries.
#

# BSTRAPDIRS1 - must be built in strict order, no parallelism
#
# order is very important. yacc before m4 before flex.  flex exec's m4,
# m4's parser file needs the latest byacc (insanity!).
#
BSTRAPDIRS1= \
	bin/chmod bin/cp bin/cpdup bin/dd bin/mkdir bin/rm bin/echo \
	bin/test bin/cat bin/ln bin/mv bin/expr bin/sh \
	bin/hostname bin/kill \
	usr.bin/yacc usr.bin/m4 usr.bin/localedef \
	usr.bin/uudecode usr.bin/xinstall \
	usr.bin/rpcgen usr.bin/bmake usr.bin/awk usr.bin/stat \
	usr.bin/find usr.bin/flex

# BSTRAPDIRS2 - may built in parallel
#
BSTRAPDIRS2= \
	usr.bin/sed usr.bin/uname usr.bin/touch \
	usr.bin/mkdep usr.bin/mktemp usr.bin/lorder usr.bin/file2c \
	usr.bin/tsort usr.bin/tr usr.bin/join usr.bin/wc usr.bin/basename \
	usr.bin/gencat usr.bin/chflags \
	usr.bin/uuencode usr.bin/cap_mkdb usr.bin/true usr.bin/false \
	usr.bin/cmp usr.bin/xargs usr.bin/env usr.bin/dirname \
	usr.bin/tail usr.bin/unifdef \
	usr.sbin/chown usr.sbin/mtree usr.sbin/config \
	usr.sbin/tzsetup usr.sbin/zic usr.sbin/pwd_mkdb \
	gnu/usr.bin/grep usr.bin/sort usr.bin/gzip \
	usr.bin/mkcsmapper usr.bin/mkesdb usr.bin/crunch

bootstrap-tools: bootstrap-tools-before bootstrap-tools-targets1 bootstrap-tools-targets2
	touch ${BTOOLSDEST}/.bootstrap_done

bootstrap-tools-before:
	${LN} -fs /bin/date ${BTOOLSDEST}/bin/date

bootstrap-tools-targets1: ${BSTRAPDIRS1:S/^/bstrap-/}

bootstrap-tools-targets2: ${BSTRAPDIRS2:S/^/bstrap-/}

.ORDER: bootstrap-tools-before bootstrap-tools-targets1 bootstrap-tools-targets2

.ORDER: ${BSTRAPDIRS1:S/^/bstrap-/}

.for _tool in ${BSTRAPDIRS1} ${BSTRAPDIRS2}
bstrap-${_tool}!
	${ECHODIR} "===> ${_tool} (bootstrap-tools)"; \
		cd ${.CURDIR}/${_tool}; \
		make DIRPRFX=${_tool}/ obj && \
		make DIRPRFX=${_tool}/ depend && \
		make DIRPRFX=${_tool}/ all && \
		make DIRPRFX=${_tool}/ DESTDIR=${BTOOLSDEST} install
.endfor

# build-tools: Build special purpose build tools.
#
# XXX we may be able to remove or consolidate this into bootstrap-tools
# now that we have the native helper (.nx/.no) infrastructure.
#
# XXX we should separate this into new Makefile.inc2.
# Just to prepare for reduction of ORDER: that slows down parallel crossworld.

# Make sure Makefile.inc1 logic is intact.
.if !defined(WORLD_ALTCOMPILER)
.warning undefined WORLD_ALTCOMPILER
.endif

# gcc80 is now the default compiler.  See sys.mk for WORLD_ALTCOMPILER default
# and this file for WORLD_CCVER.
#
_gcc47_cross= gnu/usr.bin/cc47
_gcc80_cross= gnu/usr.bin/cc80
_gcc_common_cross= lib/libz gnu/usr.bin/gmp gnu/usr.bin/mpfr gnu/usr.bin/mpc

.if !defined(NO_ALTCOMPILER)
. if defined(WORLD_ALTCOMPILER) && (${WORLD_ALTCOMPILER} == "all" || ${WORLD_ALTCOMPILER:Mgcc47})
_altcompiler_cross+= ${_gcc47_cross}
. endif
.endif

_basecompiler_cross= ${_gcc80_cross}

_custom_cross= libexec/customcc
_binutils= gnu/usr.bin/${WORLD_BINUTILSVER}

build-tools: build-tools-targets
	touch ${BTOOLSDEST}/.build_done

build-tools-targets: ${BTOOLSDIRS:S/^/btools-/}

#
# cross-tools: Build cross-building tools
#

CTOOLSDIRS= usr.bin/objformat

CTOOLSDIRS+=	${_binutils} \
		${_gcc_common_cross} \
		${_altcompiler_cross} \
		${_basecompiler_cross} ${_custom_cross}

cross-tools: cross-tools-targets
	touch ${CTOOLSDEST}/.cross_done

cross-tools-targets: ${CTOOLSDIRS:S/^/ctools-/}

.for _tool in ${CTOOLSDIRS}
ctools-${_tool}!
	${ECHODIR} "===> ${_tool} (cross-tools)"; \
		cd ${.CURDIR}/${_tool}; \
		make DIRPRFX=${_tool}/ obj && \
		make DIRPRFX=${_tool}/ depend && \
		make DIRPRFX=${_tool}/ all && \
		make DIRPRFX=${_tool}/ DESTDIR=${CTOOLSDEST} install
.endfor

#
# hierarchy - ensure that all the needed directories are present
#
hierarchy:
	cd ${.CURDIR}/etc;		make distrib-dirs

#
# libraries - build all libraries, and install them under ${DESTDIR}.
#
# The list of libraries with dependents (${_prebuild_libs}) and their
# interdependencies (__L) are built automatically by the
# ${.CURDIR}/tools/make_libdeps.sh script.
#
# .makeenv does not work when bootstrapping from 4.x, so we must be sure
# to specify the correct CCVER or 'cc' will not exec the correct compiler.
#
libraries:
	cd ${.CURDIR}; \
	    HOST_CCVER=${HOST_CCVER} CCVER=gcc80 \
		make -f Makefile.inc1 _startup_libs80 -DSYSBUILD -DLIBGCC_ONLY;
.if !defined(NO_ALTCOMPILER)
. if defined(WORLD_ALTCOMPILER) && (${WORLD_ALTCOMPILER} == "all" || ${WORLD_ALTCOMPILER:Mgcc47})
	cd ${.CURDIR}; \
	    HOST_CCVER=${HOST_CCVER} CCVER=gcc47 \
		make -f Makefile.inc1 _startup_libs47 -DSYSBUILD -DLIBGCC_ONLY;
. endif
.endif
	cd ${.CURDIR}; \
	    make -f Makefile.inc1 _startup_libs -DSYSBUILD && \
	    make -f Makefile.inc1 _prebuild_libs -DSYSBUILD && \
	    make -f Makefile.inc1 _generic_libs -DSYSBUILD && \
	    touch ${WORLDDEST}/.libraries_done

# These dependencies are not automatically generated:
#
# gnu/lib/${CCVER}/libgcc and gnu/lib/${CCVER}/csu must be built before all
# shared libraries for ELF.  The target for _startup_libsXX is
# specifically built using gccXX.
#
_startup_libs47=	gnu/usr.bin/cc47/cc_prep \
			gnu/usr.bin/cc47/cc_tools \
			gnu/lib/gcc47/csu \
			gnu/lib/gcc47/libgcc \
			gnu/lib/gcc47/libgcc_eh \
			gnu/lib/gcc47/libgcc_pic

_startup_libs80=	gnu/usr.bin/cc80/cc_prep \
			gnu/usr.bin/cc80/cc_tools \
			gnu/lib/gcc80/csu \
			gnu/lib/gcc80/libgcc \
			gnu/lib/gcc80/libgcc_eh \
			gnu/lib/gcc80/libgcc_pic

.if !defined(NO_ALTCOMPILER)
. if defined(WORLD_ALTCOMPILER) && (${WORLD_ALTCOMPILER} == "all" || ${WORLD_ALTCOMPILER:Mgcc47})
_startup_libs_alt+=	_startup_libs47
. endif
.endif

_startup_libs_base=	_startup_libs80

_startup_libs=		lib/csu lib/libc lib/libc_rtld
lib/libc__L: lib/csu__L

_prebuild_libs=		lib/libbz2 lib/liblzma lib/libz lib/libzstd
_prebuild_libs+=	lib/libutil

_prebuild_libs+=	lib/libpcap

_generic_libs=	gnu/lib

_prebuild_libs+= lib/libcrypt lib/libncurses/libncurses

_generic_libs+=	lib

_prebuild_libs+=	lib/librecrypto lib/libressl
lib/libressl__L: lib/librecrypto__L

_prebuild_libs+=       lib/libldns
lib/libldns__L: lib/librecrypto__L

_prebuild_libs+= lib/libsbuf lib/libm \
		lib/libpam/libpam lib/libypclnt lib/lib${THREAD_LIB} \
		lib/libpthread lib/libprop

_generic_libs+=	usr.bin/flex/lib

.for _alib in ${_startup_libs_alt} ${_startup_libs_base}
__startup_alibs+= ${${_alib}}
.endfor

.for _lib in ${__startup_alibs} \
		${_startup_libs} ${_prebuild_libs} ${_generic_libs}
${_lib}__L: .PHONY
.if exists(${.CURDIR}/${_lib})
	@${ECHODIR} "===> ${_lib}"; \
		cd ${.CURDIR}/${_lib}; \
		echo "STEP DEP ${_lib}" && \
		make DIRPRFX=${_lib}/ depend && \
		echo "STEP ALL ${_lib}" && \
		make DIRPRFX=${_lib}/ all && \
		echo "STEP INSTALL ${_lib}" && \
		make DIRPRFX=${_lib}/ install && \
		echo "STEP DONE ${_lib}";
.else
.warning missing ${.CURDIR}/${_lib} directory.
.endif
.endfor

_startup_libs: ${_startup_libs:S/$/__L/}
.for _alib in ${_startup_libs_alt} ${_startup_libs_base}
${_alib}: ${${_alib}:C/$/__L/}
.endfor
_prebuild_libs: ${_prebuild_libs:S/$/__L/}
_generic_libs: ${_generic_libs:S/$/__L/}

# library targets must be ordered because there are inter-library
# races (e.g. generation of tconfig.h)
#
.for _alib in ${_startup_libs_base} ${_startup_libs_alt}
.ORDER: ${${_alib}:C/$/__L/}
.endfor

# uncomment if there are missing dependencies
.if 0
.ORDER: ${_prebuild_libs:S/$/__L/}
# we can disable this one, no lib/* depend on libstdc++
.ORDER: ${_generic_libs:S/$/__L/}
.endif

.for __target in clean cleandepend cleandir obj depend includes
.for entry in ${SUBDIR}
${entry}.${__target}__D: .PHONY
	@if test -d ${.CURDIR}/${entry}.${MACHINE_ARCH}; then \
		${ECHODIR} "===> ${DIRPRFX}${entry}.${MACHINE_ARCH}"; \
		edir=${entry}.${MACHINE_ARCH}; \
		cd ${.CURDIR}/$${edir}; \
	else \
		${ECHODIR} "===> ${DIRPRFX}${entry}"; \
		edir=${entry}; \
		cd ${.CURDIR}/$${edir}; \
	fi; \
	make ${__target} DIRPRFX=${DIRPRFX}$${edir}/
.endfor
par-${__target}: ${SUBDIR:C/$/.${__target}__D/}
.ORDER: ${SUBDIR:C/$/.${__target}__D/}
.endfor
.ORDER: par-clean par-cleandepend par-cleandir par-obj par-depend par-includes

# The wmake target is used by /usr/bin/wmake to run make in a
# world build environment.
#
wmake:
	@echo '${WMAKEENV} make ${WMAKE_ARGS} -DSYSBUILD'

wmakeenv:
	@echo '${WMAKEENV} /bin/sh'

bmake:
	@echo '${BMAKEENV} make ${BMAKE_ARGS} -DSYSBUILD'

bmakeenv:
	@echo '${BMAKEENV} /bin/sh'

tmake:
	@echo '${TMAKEENV} make ${TMAKE_ARGS} -DSYSBUILD'

tmakeenv:
	@echo '${TMAKEENV} /bin/sh'

xmake:
	@echo '${XMAKEENV} make ${XMAKE_ARGS} -DSYSBUILD'

xmakeenv:
	@echo '${XMAKEENV} /bin/sh'

.if !defined(NO_BACKUP)
backupworld: backup-clean
	@mkdir -p ${WORLD_BACKUP}
.if (exists(${DESTDIR}/sbin) && exists(${DESTDIR}/bin) && \
     exists(${DESTDIR}/usr/sbin) && exists(${DESTDIR}/usr/bin) && \
     exists(${DESTDIR}/usr/lib) && exists(${DESTDIR}/usr/libexec))
	tar -czf ${WORLD_BACKUP}/binaries.tar.gz -C ${DESTDIR}/ \
		--options gzip:compression-level=1 \
		sbin bin usr/sbin usr/bin usr/lib usr/libexec
.endif

backupworld-auto:
	rm -f ${AUTO_BACKUP}/binaries.tar.gz
	@mkdir -p ${AUTO_BACKUP}
.if (exists(${DESTDIR}/sbin) && exists(${DESTDIR}/bin) && \
     exists(${DESTDIR}/usr/sbin) && exists(${DESTDIR}/usr/bin) && \
     exists(${DESTDIR}/usr/lib) && exists(${DESTDIR}/usr/libexec))
	/usr/bin/tar -czf ${AUTO_BACKUP}/binaries.tar.gz -C ${DESTDIR}/ \
		--options gzip:compression-level=1 \
		sbin bin usr/sbin usr/bin usr/lib usr/libexec
.endif

backup-auto-clean:
	rm -f ${AUTO_BACKUP}/binaries.tar.gz

backup-clean:
	rm -f ${WORLD_BACKUP}/binaries.tar.gz

restoreworld:
.if !exists(${WORLD_BACKUP}/binaries.tar.gz)
	@echo "There does not seem to be a valid archive present."
.else
	@echo "Restoring system binaries from manual backup archive..."
	@chflags -R noschg ${DESTDIR}/sbin ${DESTDIR}/bin \
		${DESTDIR}/usr/sbin ${DESTDIR}/usr/bin \
		${DESTDIR}/usr/lib ${DESTDIR}/usr/libexec
	tar -xzf ${WORLD_BACKUP}/binaries.tar.gz -C ${DESTDIR}/
.endif

restoreworld-auto:
.if !exists(${AUTO_BACKUP}/binaries.tar.gz)
	@echo "There does not seem to be a valid archive present."
.else
	@echo "Restoring system binaries from auto-backup archive..."
	@chflags -R noschg ${DESTDIR}/sbin ${DESTDIR}/bin \
		${DESTDIR}/usr/sbin ${DESTDIR}/usr/bin \
		${DESTDIR}/usr/lib ${DESTDIR}/usr/libexec
	tar -xzf ${AUTO_BACKUP}/binaries.tar.gz -C ${DESTDIR}/
.endif
.endif

# Take advantage of bmake error response
#
MAKE_PRINT_VAR_ON_ERROR= \
	.CURDIR \
	.OBJDIR \
	.TARGETS \
	.ERROR_TARGET \
	.MAKE.LEVEL \
	.MAKE.MODE \
	PATH \
	LD_LIBRARY_PATH \
	MACHINE_ARCH \
	MACHINE \
	MAKEFILE \
	MAKESYSPATH \
	MAKEOBJDIRPREFIX \
	WORLD_ALTCOMPILER \
	DESTDIR \
	SHELL .SHELL
.if ${.MAKE.LEVEL} > 0
MAKE_PRINT_VAR_ON_ERROR+= .MAKE.MAKEFILES .PATH
.endif

.include <bsd.subdir.mk>
